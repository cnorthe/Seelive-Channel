<#     
============================================================================================
        Script: Baseline-Functions.ps1
        Author: Andrew Kraemer
        Version: 1.0.0.0
    ---------------------------------------------------------
    .DESCRIPTION
    Common functions across baseline capabilities

    NOTE: Variables from Header-All.ps1 may be used
    
    ---------------------------------------------------------
    History:
    Ver               Modifications
    ---------------------------------------------------------
    1.0.0.0             
    
============================================================================================
#>

# Load SQL Module
Function Import-SQL-Module() {
    Import-Module "${IncludePath}\Invoke-SqlCmd2"
}

Function Get-Current-Component-Path($ComponentName) {
    Return "${CurrentConfigPath}\${ComponentName}"
}

Function Get-Baseline-Component-Path($ComponentName) {
    Return "${BaselineConfigPath}\${ComponentName}"
}

# Returns DataTable
Function Run-SQL-Query($Query) {
    $Results = Invoke-Sqlcmd2 -Query $Query -ServerInstance "CM01" -Database "CM_CM1" -As DataTable
    Return ,$Results
}

Function Create-Baseline-File($Name, $Timestamp, $Data) {
    $CurrentComponentPath = Get-Current-Component-Path -ComponentName $ComponentName
    $Filename = "${Name}.${Timestamp}.baseline"
    $LatestFile = "${CurrentComponentPath}\${Filename}"

    # Remove blank lines
    $Data = $Data | ? {$_.Trim() -ne ""}
    
    # Remove any whitespace at beginning or end
    $Data = $Data.Trim()
    
    # Save the file
    Set-Content -Path $LatestFile -Value $Data -NoNewline -Force

    Return $LatestFile
}

Function Create-Component-Metadata([Array]$Objects) {
    # Create Component Metadata
    $Path = Get-Current-Component-Path -ComponentName $ComponentName
    $XMLPath = "${Path}\ComponentBaseline.xml"

    $CurrentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
    $Domain = $env:USERDOMAIN
    $DNSDomain = $env:USERDNSDOMAIN

    [xml]$XML = New-Object System.Xml.XmlDocument
    $Declaration = $XML.CreateXmlDeclaration("1.0", "UTF-8", $null)
    $XML.AppendChild($Declaration) | Out-Null

    $Comment = @"
Module: $ModuleName
Component: $ComponentName
Generated By: $CurrentUser
Date: $Date
"@

    $XML.AppendChild($XML.CreateComment($Comment)) | Out-Null

    $XMLNode = $XML.CreateNode("element", "Component", $null)
    $XMLNode.SetAttribute("Name", $ComponentName)
    $XMLNode.SetAttribute("Module", $ModuleName)
    $XMLNode.SetAttribute("Timestamp", $Timestamp)
    $XMLNode.SetAttribute("User", $CurrentUser)
    $XMLNode.SetAttribute("Domain", $Domain)
    $XMLNode.SetAttribute("DNSDomain", $DNSDomain)

    Foreach($Object in $Objects) {
        # Name
        # Timestamp
        # Filename

        $XMLObject = $XML.CreateNode("element", "Object", $null)
        $XMLObject.SetAttribute("Name", $Object.Name)

        $XMLFilename = $XML.CreateNode("element", "Filename", $null)
        $XMLFilename.InnerText = $Object.Filename
        $XMLObject.AppendChild($XMLFilename) | Out-Null

        $XMLTimestamp = $XML.CreateNode("element", "Timestamp", $null)
        $XMLTimestamp.InnerText = $Object.Timestamp
        $XMLObject.AppendChild($XMLTimestamp) | Out-Null

        $XMLHash = $XML.CreateNode("element", "SHA512", $null)
        $XMLHash.InnerText = $Object.SHA512
        $XMLObject.AppendChild($XMLHash) | Out-Null

        $XMLNode.AppendChild($XMLObject) | Out-Null
    }

    $XML.AppendChild($XMLNode) | Out-Null

    $XML.Save($XMLPath)
}

Function Create-Baseline-Files($ComponentData) {

    $MetadataObjects = New-Object System.Collections.ArrayList

    Foreach($ObjectData in $ComponentData) {
        $FilePath = Create-Baseline-File -Name $ObjectData.Name -Timestamp $ObjectData.Timestamp -Data $ObjectData.Data
        $FileName = (Get-Item -Path $FilePath).Name
        $FileHash = Get-FileHash -Path $FilePath -Algorithm SHA512
        $Hash = $FileHash.Hash

        $ObjectMetadata = [PSCustomObject]@{
            "Name" = $ObjectData.Name
            "Timestamp" = $ObjectData.Timestamp
            "Filename" = $FileName
            "SHA512" = $Hash
        }
        $MetadataObjects.Add($ObjectMetadata) | Out-Null
    }

    Create-Component-Metadata -Objects $MetadataObjects
}

Function Process-DataTable([System.Data.DataTable]$DataTable, $Path) {
    $Names = $DataTable | Select-Object -ExpandProperty "Name" | Sort-Object -Unique

    $AdditionalColumns = @($DataTable.Columns.ColumnName | Where { $_ -ne "Name" })

    $BaselineObjects = New-Object System.Collections.ArrayList

    Foreach($Name in $Names) {
        $Filename = "${Name}.${Timestamp}.baseline"
        $LatestFile = "${Path}\${Filename}"
        $Data = @($DataTable | Where { $_.Name -eq $Name } | Select-Object -Property $AdditionalColumns)
        $SortedData = $Data | Sort-Object -Property $AdditionalColumns[0]

        # Get string output
        $DataString = [System.String]::Join("`n", $SortedData)

        $ObjectData = [PSCustomObject]@{
            "Name" = $Name
            "Timestamp" = $Timestamp
            "Data" = $DataString
        }

        $BaselineObjects.Add($ObjectData) | Out-Null
    }

    Return $BaselineObjects
}

Function Set-Baseline($Component) {
    $ComponentBaselinePath = "${BaselineConfigPath}\${Component}"
    $ComponentBaselineXML = "${ComponentBaselinePath}\ComponentBaseline.xml"

    # Archive the current baseline

    if(Test-Path -Path $ComponentBaselineXML) {
        [xml]$ComponentXML = Get-Content $ComponentBaselineXML
        $Timestamp = $ComponentXML.Component.Timestamp
        $ArchivePath = "${BaselineArchivesPath}\${Timestamp}"
        New-Item -Path $ArchivePath -ItemType Directory -Force | Out-Null
        $ComponentArchivePath = "${ArchivePath}\${Component}"
        if(-not (Test-Path -Path $ComponentArchivePath)) {
            New-Item -Path $ComponentArchivePath -ItemType Directory -Force | Out-Null
            Copy-Item -Path "${ComponentBaselinePath}\*" -Destination $ComponentArchivePath -Force
            Remove-Item -Path $ComponentBaselinePath -Recurse -Force
        }
    }

    New-Item -Path $ComponentBaselinePath -ItemType Directory -Force | Out-Null
    Copy-Item -Path "${CurrentConfigPath}\${Component}\*" -Destination $ComponentBaselinePath -Recurse -Force
}

Function Create-Baseline-Directories($ComponentName) {
    New-Item -Path $BaselineConfigPath -ItemType Directory -Force | Out-Null
    New-Item -Path $CurrentConfigPath -ItemType Directory -Force | Out-Null
    New-Item -Path $BaselineArchivesPath -ItemType Directory -Force | Out-Null
}

Function Recreate-Directory($Path) {
    if(Test-Path -Path $Path) {
        Remove-Item -Path $Path -Recurse -Force
    }
    New-Item -Path $Path -ItemType Directory -Force | Out-Null
}


Function GenerateForm($Title, $GridWidth, $OnLoadForm_GetComponents, $SelectAll = $True, $ClearAll = $True, $Cancel = $True, $OK = $True) {
    [Void][Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms")

    $ButtonSelectAll = New-Object Windows.Forms.Button
    $ButtonSelectAll.Location = New-Object Drawing.Point 20,520
    $ButtonSelectAll.size = New-Object Drawing.Point 90,28
    $ButtonSelectAll.Text = "Select &All"
    $ButtonSelectAll.add_click({ButtonSelectAll_OnClick})

    $ButtonClearAll = New-Object Windows.Forms.Button
    $ButtonClearAll.Location = New-Object Drawing.Point 120,520
    $ButtonClearAll.size = New-Object Drawing.Point 90,28
    $ButtonClearAll.Text = "Clear &All"
    $ButtonClearAll.add_Click({ButtonClearAll_OnClick})

    $ButtonOK = New-Object Windows.Forms.Button
    $ButtonOK.Location = New-Object Drawing.Point 510,520
    $ButtonOK.size = New-Object Drawing.Point 90,28
    $ButtonOK.Text = "&OK"
    $ButtonOK.add_Click({ButtonOK_OnClick})

    $ButtonCancel = New-Object Windows.Forms.Button
    $ButtonCancel.Location = New-Object Drawing.Point 610,520
    $ButtonCancel.size = New-Object Drawing.Point 90,28
    $ButtonCancel.Text = "&Cancel"
    $ButtonCancel.add_click({ButtonCancel_OnClick})

    $DataGridView1 = New-Object System.Windows.Forms.DataGridView
    $DataGridView1.Location = New-Object Drawing.Point 10,10 #,40
    $DataGridView1.size = New-Object Drawing.Point $GridWidth,500
    $DataGridView1.MultiSelect = $false
    $DataGridView1.ColumnHeadersVisible = $true
    $DataGridView1.RowHeadersVisible = $false

    $Form = New-Object Windows.Forms.Form
    $Form.text = $Title
    $Form.Size = New-Object Drawing.Point 730,590
    $Form.topmost = 1
    #$Form.Icon = [system.drawing.icon]::ExtractAssociatedIcon($PSHOME + "\powershell.exe")
    $Form.FormBorderStyle = "Fixed3D"
    $Form.MaximizeBox = $False
    $Form.StartPosition = "CenterScreen"

    $Form.Controls.Add($DataGridView1)
    if($SelectAll) {
        $Form.Controls.add($ButtonSelectAll)
    }
    if($ClearAll) {
        $Form.Controls.Add($ButtonClearAll)
    }
    if($OK) {
        $Form.Controls.add($ButtonOK)
    }
    if($Cancel) {
        $Form.Controls.add($ButtonCancel)
    }

    
    $Form.add_Load($OnLoadForm_GetComponents)
    $Form.ShowDialog() | Out-Null
    Return $Form
}

Function ButtonSelectAll_OnClick {
    for($i=0;$i -lt $DataGridView1.RowCount;$i++) { 
       if($DataGridView1.Rows[$i].Cells[0].ReadOnly -eq $False) {
        $DataGridView1.Rows[$i].Cells[0].Value = $True
       }
    }
}

Function ButtonClearAll_OnClick {
    for($i=0;$i -lt $DataGridView1.RowCount;$i++) { 
       $DataGridView1.Rows[$i].Cells[0].Value = $False
    }
}

Function ButtonCancel_OnClick {
    Write-Host "Cancelled"
    $Form.Close()
    $global:Cancelled = $True
}

Function ButtonOK_OnClick {
    #== Open config file for writing
    for($i=0;$i -lt $datagridview1.RowCount;$i++) { 
        #== Update status to 0 for any selected rows
        if($datagridview1.Rows[$i].Cells[0].Value -eq $true) {
            $SelectedName = $DataGridView1.Rows[$i].Cells[1].Value
            Write-Host "Selected Component: $SelectedName"
            $global:SelectedComponents.Add($SelectedName) | Out-Null
        }
    }
    $Form.Close()
}

Function Timestamp-To-Date($Time) {
    $DateTime = [datetime]::ParseExact($Time, "yyyyMMddTHHmmss", $null)
    Return $DateTime.ToString()
}

Function Sort-File($FilePath) {
    $ls = new-object system.collections.generic.List[string];
    $reader = [System.IO.File]::OpenText($FilePath)
    try {
        while (($line = $reader.ReadLine()) -ne $null) {
            $ls.Add($line)
        }
    } finally {
        $reader.Close()
    }

    $ls.Sort();

    try {
        $f = New-Object System.IO.StreamWriter($FilePath)
        foreach ($s in $ls) {
            $f.WriteLine($s);
        }
    } finally {
        $f.Close();
    }
}

Function Audit-Component-Baseline($Component) {

    $ComponentBaselinePath = "${BaselineConfigPath}\${Component}"
    $ComponentBaselineXML = "${ComponentBaselinePath}\ComponentBaseline.xml"

    $ComponentAuditPath = "${CurrentConfigPath}\${Component}"
    $ComponentAuditXML = "${ComponentAuditPath}\ComponentBaseline.xml"

    if(-not (Test-Path -Path $ComponentBaselineXML)) {
        Write-Error "Baseline XML for ${Component} not found"
        Return
    }
    if(-not (Test-Path -Path $ComponentAuditXML)) {
        Write-Error "Audit configuration XML for ${Component} not found"
        Return
    }

    [xml]$XMLComponentBaseline = Get-Content -Path $ComponentBaselineXML
    [xml]$XMLComponentAudit = Get-Content -Path $ComponentAuditXML

    $ComponentResults = New-Object System.Collections.ArrayList

    $ComponentObject = $Components | Where { $_.Component -eq $Component }
    $ModuleName = $ComponentObject.Module

    $BaselineTimestamp = $XMLComponentBaseline.Component.Timestamp
    $BaselineDomain = $XMLComponentBaseline.Component.Domain
    $BaselineDNSDomain = $XMLComponentBaseline.Component.DNSDomain
    $BaselineUser = $XMLComponentBaseline.Component.User
    $AuditTimestamp = $XMLComponentAudit.Component.Timestamp
    $AuditDomain = $XMLComponentAudit.Component.Domain
    $AuditDNSDomain = $XMLComponentAudit.Component.DNSDomain
    $AuditUser = $XMLComponentAudit.Component.User
    
    $BaselineObjects = $XMLComponentBaseline.Component.Object
    $AuditObjects = $XMLComponentAudit.Component.Object

    Foreach($BaselineObject in $BaselineObjects) {
        $ObjectName = $BaselineObject.Name
        $BaselineObjectFilename = $BaselineObject.Filename
        $BaselineObjectTimestamp = $BaselineObject.Timestamp
        $BaselineObjectFilePath = "${ComponentBaselinePath}\${BaselineObjectFilename}"
        Write-Host "`tAuditing ${Component}:${ObjectName}"

        $BaselineList = New-Object System.Collections.Generic.List[string]
        $reader = [System.IO.File]::OpenText($BaselineObjectFilePath)
        try {
            while (($line = $reader.ReadLine()) -ne $null) {
                $BaselineList.Add($line)
            }
        } finally {
            $reader.Close()
        }

        $BaselineList.Sort();

        $AuditObject = $AuditObjects | Where { $_.Name -eq $ObjectName }
        if($AuditObject -eq $null) {
            Write-Host "`t`tMissing ${ObjectName} from current configuration"
            $Result = [PSCustomObject]@{
                "Component" = $Component
                "Module" = $ModuleName
                "BaselineDomain" = $BaselineDomain
                "BaselineDNSDomain" = $BaselineDNSDomain
                "BaslineUser" = $BaselineUser
                "AuditDomain" = $AuditDomain
                "AuditDNSDomain" = $AuditDNSDomain
                "AuditUser" = $AuditUser
                "Result" = "AUDITMISSING"
                "BaselineTimestamp" = $BaselineTimestamp
                "AuditTimestamp" = $AuditTimestamp
                "ObjectName" = $ObjectName
                "BaselineObject" = $BaselineObject
                "AuditObject" = $null
                "BaselineData" = $BaselineList
                "AuditData" = $null
                "Added" = $null
                "Removed" = $null
            }
            $ComponentResults.Add($Result) | Out-Null
            Continue
        }

        $AuditObjectFilename = $AuditObject.Filename
        $AuditObjectTimestamp = $AuditObject.Timestamp
        $AuditObjectFilePath = "${ComponentAuditPath}\${AuditObjectFilename}"

        $AuditList = New-Object System.Collections.Generic.List[string]
        $reader = [System.IO.File]::OpenText($AuditObjectFilePath)
        try {
            while (($line = $reader.ReadLine()) -ne $null) {
                $AuditList.Add($line)
            }
        } finally {
            $reader.Close()
        }

        $AuditList.Sort();

        $Added = New-Object System.Collections.Generic.List[string]
        $Removed = New-Object System.Collections.Generic.List[string]

        Foreach($BaselineItem in $BaselineList) {
            $Index = $AuditList.IndexOf($BaselineItem)
            if($Index -gt -1) {
                $AuditList.RemoveAt($Index)
                Continue
            }
            $Removed.Add($BaselineItem)
        }
        Foreach($AuditItem in $AuditList) {
            $Added.Add($AuditItem)
        }

        if ($Added.Count -eq 0 -and $Removed.Count -eq 0) {
            # No Software Change
            Write-Host "`t`tBaseline Match"
            $Result = [PSCustomObject]@{
                "Component" = $Component
                "Module" = $ModuleName
                "BaselineDomain" = $BaselineDomain
                "BaselineDNSDomain" = $BaselineDNSDomain
                "BaslineUser" = $BaselineUser
                "AuditDomain" = $AuditDomain
                "AuditDNSDomain" = $AuditDNSDomain
                "AuditUser" = $AuditUser
                "Result" = "MATCH"
                "BaselineTimestamp" = $BaselineTimestamp
                "AuditTimestamp" = $AuditTimestamp
                "ObjectName" = $ObjectName
                "BaselineObject" = $BaselineObject
                "AuditObject" = $AuditObject
                "BaselineData" = $BaselineList
                "AuditData" = $AuditList
                "Added" = $null
                "Removed" = $null
            }
            $ComponentResults.Add($Result) | Out-Null
        } else {
            # Software Change
            Write-Host "`t`tBaseline Change" -ForegroundColor Yellow
            $Result = [PSCustomObject]@{
                "Component" = $Component
                "Module" = $ModuleName
                "BaselineDomain" = $BaselineDomain
                "BaselineDNSDomain" = $BaselineDNSDomain
                "BaslineUser" = $BaselineUser
                "AuditDomain" = $AuditDomain
                "AuditDNSDomain" = $AuditDNSDomain
                "AuditUser" = $AuditUser
                "Result" = "CHANGE"
                "BaselineTimestamp" = $BaselineTimestamp
                "AuditTimestamp" = $AuditTimestamp
                "ObjectName" = $ObjectName
                "BaselineObject" = $BaselineObject
                "AuditObject" = $AuditObject
                "BaselineData" = $BaselineList
                "AuditData" = $AuditList
                "Added" = $Added
                "Removed" = $Removed
            }
            $ComponentResults.Add($Result) | Out-Null
        }
    }

    Foreach($AuditObject in $AuditObjects) {
        $ObjectName = $AuditObject.Name
        $AuditObjectFilename = $AuditObject.Filename
        $AuditObjectTimestamp = $AuditObject.Timestamp
        $AuditObjectFilePath = "${ComponentAuditPath}\${AuditObjectFilename}"

        $AuditObjectContent = Get-Content -Path $AuditObjectFilePath -Raw
        $BaselineObject = $BaselineObjects | Where { $_.Name -eq $ObjectName }
        if($BaselineObject -eq $null) {
            Write-Host "`t`tMissing ${ObjectName} from baseline configuration"
            $Result = [PSCustomObject]@{
                "Component" = $Component
                "Module" = $ModuleName
                "BaselineDomain" = $BaselineDomain
                "BaselineDNSDomain" = $BaselineDNSDomain
                "BaslineUser" = $BaselineUser
                "AuditDomain" = $AuditDomain
                "AuditDNSDomain" = $AuditDNSDomain
                "AuditUser" = $AuditUser
                "Result" = "BASELINEMISSING"
                "BaselineTimestamp" = $BaselineTimestamp
                "AuditTimestamp" = $AuditTimestamp
                "ObjectName" = $ObjectName
                "BaselineObject" = $null
                "AuditObject" = $AuditObject
                "BaselineData" = $null
                "AuditData" = $AuditList
                "Added" = $null
                "Removed" = $null
            }
            $ComponentResults.Add($Result) | Out-Null
            Continue
        }
    }

    Return $ComponentResults | Sort-Object -Property "ObjectName"
}

Function Generate-HTML-Report($AuditResults) {
    New-Item -Path $ReportsPath -ItemType Directory -Force | Out-Null
    $ThisReportPath = "${ReportsPath}\${Timestamp}"
    if(Test-Path -Path $ThisReportPath) {
        Remove-Item -Path $ThisReportPath -Recurse -Force
    }
    New-Item -Path $ThisReportPath -ItemType Directory -Force | Out-Null
    $ComponentsReportDir = "${ThisReportPath}\Components"
    New-Item -Path $ComponentsReportDir -ItemType Directory -Force | Out-Null
    $ThisResourcesPath = "${ThisReportPath}\Resources\"
    New-Item -Path $ThisResourcesPath -ItemType Directory -Force | Out-Null
    $ReportResources = "${IncludePath}\ReportResources"
    Copy-Item -Path "${ReportResources}\*" -Destination $ThisResourcesPath -Recurse -Force

    $ComponentTypes = $AuditResults.Component | Sort-Object -Unique

    $FirstAudit = $AuditResults | Select-Object -First 1
    $DNSDomain = $FirstAudit.BaselineDNSDomain

    #
    # CREATE INDEX PAGE
    #

    $Index = 
@"
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

"@

    # Add <head>
    $Index += 
@"
<head>
    <title>$DNSDomain</title>
    <link rel="stylesheet" href="./Resources/css/styles.css" />
</head>

"@
    # Add body and table header
    $Index += 
@"
<body>
    <div id="container">
        <div id="componentsummaries">
			<div id="summaries">
				<div class="summaryrow">
					<div class="summaryheader">Component</div>
					<div class="summaryheader">Module</div>
					<div class="summaryheader">Baseline Date</div>
					<div class="summaryheader">Audit Date</div>
					<div class="summaryheader">Audit Result</div>
					<div class="summaryheader">% Match</div>
				</div>

"@
    
    Foreach($ComponentName in $ComponentTypes) {
        $ComponentResults = $AuditResults | Where { $_.Component -eq $ComponentName }
        $AuditObject = $AuditResults | Where { $_.Component -eq $ComponentName } | Select-Object -First 1
        $ModuleName = $AuditObject.Module
        $BaselineDate = Timestamp-To-Date -Time $AuditObject.BaselineTimestamp
        $AuditDate = Timestamp-To-Date -Time $AuditObject.AuditTimestamp
        $TotalCount = $ComponentResults.Count
        $MatchCount = ($ComponentResults | Where { $_.Result -eq "MATCH" } | Measure-Object).Count
        $MatchPercent = [Math]::Round(($MatchCount / $TotalCount) * 100, 0)
        $Result = "Pass"
        $ComponentIssues = $ComponentResults | Where { $_.Result -ne "MATCH" }
        if($ComponentIssues -ne $null) {
            $Result = "Fail"
        }

        $Link = "./Components/${ComponentName}.html"
        
        $Index += 
@"
                <div class="summaryrow">
                    <div class="summary"><a href='${Link}'>${ComponentName}</a></div>
                    <div class="summary">${ModuleName}</div>
                    <div class="summary">${BaselineDate}</div>
                    <div class="summary">${AuditDate}</div>
                    <div class="summary">${Result}</div>
                    <div class="summary">${MatchPercent}%</div>
                </div>

"@
    }

    # End table body html
    $Index += 
@"
            </div> <!-- .summaries -->
        </div> <!-- #componentsummaries -->
    </div> <!-- #container -->
</body>
</html>
"@

    Set-Content -Value $Index -Path "${ThisReportPath}\index.html" -Force

    Foreach($ComponentName in $ComponentTypes) {
        $ComponentResults = $AuditResults | Where { $_.Component -eq $ComponentName }
        $AuditObject = $AuditResults | Where { $_.Component -eq $ComponentName } | Select-Object -First 1
        $ModuleName = $AuditObject.Module
        $BaselineDate = Timestamp-To-Date -Time $AuditObject.BaselineTimestamp
        $AuditDate = Timestamp-To-Date -Time $AuditObject.AuditTimestamp
        $Result = "Pass"
        $ComponentIssues = $ComponentResults | Where { $_.Result -ne "MATCH" }
        if($ComponentIssues -ne $null) {
            $Result = "Fail"
        }

        $TotalCount = $ComponentResults.Count
        $MatchCount = ($ComponentResults | Where { $_.Result -eq "MATCH" } | Measure-Object).Count
        $MatchPercent = [Math]::Round(($MatchCount / $TotalCount) * 100, 0)
        $ChangeCount = ($ComponentResults | Where { $_.Result -eq "CHANGE" } | Measure-Object).Count
        $ChangePercent = [Math]::Round(($ChangeCount / $TotalCount) * 100, 0)
        $BaselineMissingCount = ($ComponentResults | Where { $_.Result -eq "BASELINEMISSING" } | Measure-Object).Count
        $BaselineMissingPercent = [Math]::Round(($BaselineMissingCount / $TotalCount) * 100, 0)
        $AuditMissingCount = ($ComponentResults | Where { $_.Result -eq "AUDITMISSING" } | Measure-Object).Count
        $AuditMissingPercent = [Math]::Round(($AuditMissingCount / $TotalCount) * 100, 0)
        $Domain = $AuditObject.BaselineDomain
        $DNSDomain = $AuditObject.BaselineDNSDomain

        

        $Title = "${ComponentName} - ${DNSDomain}"
        

        # Build Component HTML File
        $ComponentPage = 
@"
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

"@
        $ComponentPage += 
@"
<head>
    <title>${Title}</title>
    <link rel="stylesheet" href="../Resources/css/styles.css" />
</head>

"@
        $ComponentPage += 
@"
<body>
    <div id="container">
        <div id="componenttop">
            <div class="componentheaders">
                <div class="topheader">
                    <div class="headertlcorner">${DNSDomain}</div>
                    <div class="headertrcorner">${ModuleName}</div>
                </div>
                <div class="componentheader">${ComponentName}</div>
                <div class="headerdates">
                    <div class="headerdate">Baseline: ${BaselineDate}</div>
                    <div class="headerdate">Audit: ${AuditDate}</div>
                </div>
                <div class="metrics">
                    <div class="metric">Total Objects<span>${TotalCount}</span></div>
                    <div class="metric">Matching<span>${MatchCount} (${MatchPercent}%)</span></div>
                    <div class="metric">Changes<span>${ChangeCount} (${ChangePercent}%)</span></div>
                    <div class="metric">Not Part of Baseline<span>${BaselineMissingCount} (${BaselineMissingPercent}%)</span></div>
                    <div class="metric">Baseline Object Missing<span>${AuditMissingCount} (${AuditMissingPercent}%)</span></div>
                </div>
            </div>
        </div>

        <div id="main">

"@

        Foreach($ComponentResult in $ComponentResults) {
            $ObjectName = $ComponentResult.ObjectName
            $Result = $ComponentResult.Result
            $ComponentPage += 
@"
            <div class="comprow class${Result}">
                <div class="compinfosrow">
                    <div class="compinfosheader">
                        <div class="compinfoheader compinfoheader1">${ObjectName}</div>
                        <div class="compinfoheader compinfoheader2">${Result}</div>
                    </div>
                </div>

"@
            if($Result -eq "CHANGE") {
                $lhs = [system.String]::Join("`n", $ComponentResult.Removed)
                $rhs = [system.String]::Join("`n", $ComponentResult.Added)
                $ComponentPage += 
@"
                <div class="changerowtable">
                    <div class="changeheaderrow">
                        <div class="changeheader">Removed</div>
                        <div class="changeheader">Added</div>
                    </div>
                    <div class="changerow">  
                        <div class="lhs">$lhs</div>
                        <div class="rhs">$rhs</div>
                    </div>
                </div>
    
"@
            }
            $ComponentPage += 
@"
            </div>

"@          
        }

        $ComponentPage += @"
        </div>
    </div>
</body>
</html>
"@
        Set-Content -Value $ComponentPage -Path "${ComponentsReportDir}\${ComponentName}.html" -Force

    }

    $XMLOutputPath = "${ThisReportPath}\Audit-${DNSDomain}-${Timestamp}.xml"
    $XMLOutput = $AuditResults | ConvertTo-Xml
    $XMLOutput.Save($XMLOutputPath)

    Return $ThisReportPath

}